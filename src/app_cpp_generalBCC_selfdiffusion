/* ----------------------------------------------------------------------
   SPPARKS - Stochastic Parallel PARticle Kinetic Simulator
   http://www.cs.sandia.gov/~sjplimp/spparks.html
   Steve Plimpton, sjplimp@sandia.gov, Sandia National Laboratories

   Copyright (2008) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level SPPARKS directory.
------------------------------------------------------------------------- */

#include "math.h"
#include "string.h"
#include "stdlib.h"
#include "solve.h"
#include "domain.h"
#include "random_park.h"
#include "memory.h"
#include "error.h"
#include "app_bcc_selfdiffusion.h"

using namespace SPPARKS_NS;
using std::map;
using std::set;

enum{LINEAR};
enum{ANNIATSINK,ANNI,ONSITEROT,TRANS,NNTRANSROT,NNNTRANSROT,EXCHANGE};

#define DELTAEVENT 100000

// This app is based on the diffusion_multiphase app
// These are the significant changes 
// 1. Three components: vacancy, Fe atoms and Fe-Fe dumbbells
// 2. All three can exchange with each other 

/* ---------------------------------------------------------------------- */

AppBccSelfdiffusion::AppBccSelfdiffusion(SPPARKS *spk, int narg, char **arg) :
  AppLattice(spk,narg,arg)
{
  // need to double check these values

  ninteger = 2;
  ndouble = 0;
  delpropensity = 2;
  delevent = 1;
  allow_kmc = 1;
  allow_rejection = 1;
  allow_masking = 0;
  numrandom = 1;

  // no args for this app

  if (narg > 1) error->all(FLERR,"Illegal app_style command");

  engstyle = LINEAR;

  create_arrays();
  esites = NULL;
  echeck = NULL;
  maxevent = 0;
  events = NULL;
  firstevent = NULL;

  allocated = 0;

  naccept_danni = naccept_vanni = naccept_dvanni = 0;
  naccept_rot = naccept_nntr = naccept_nnt = naccept_nnntr = 0;
  naccept_VFex = 0;

}

/* ---------------------------------------------------------------------- */

AppBccSelfdiffusion::~AppBccSelfdiffusion()
{
  delete [] esites;
  delete [] echeck;
  memory->sfree(events);
  memory->destroy(firstevent);
}

/* ----------------------------------------------------------------------
   input script commands unique to this app
------------------------------------------------------------------------- */

void AppBccSelfdiffusion::input_app(char *command, int narg, char **arg)
{
  if (sites_exist == 0) {
    char str[128];
    sprintf(str,"Cannot use %s command until sites exist",command);
    error->all(FLERR,str);
  }

  if (!allocated) allocate_data();
  allocated = 1;

  if (strcmp(command,"bcc/selfdiffusion") == 0)
    parse_bccselfdiffusion(narg,arg);
  else 
   error->all(FLERR,"Unrecognized command in parse");
}

/* ---------------------------------------------------------------------- */

void AppBccSelfdiffusion::parse_bccselfdiffusion(int narg, char **arg)
{
   // 2 args: bcc/selfdiffusion rate <double value>
   // 2 args: bcc/selfdiffusion energy <double value> 

   if (narg < 2)
     error->all(FLERR,"Illegal bcc/selfdiffusion command");

   if (strcmp(arg[0], "rate") == 0) {
       if (narg != 3) {
            error->all(FLERR, "Illegal bcc/selfdiffusion rate command: "
                               "Expected 'rate <name> <value>'");
        } 
        std::string rate_name = arg[1]; // The name of the rate variable 
					// (e.g., "V_anniAtSinks")
        double rate_value = std::atof(arg[2]); // Using std::atof as requested

        // Assign the value to the corresponding member variable
        if (rate_name == "V_anniAtSinks") {
            V_anniAtSinks = rate_value;
        } else if (rate_name == "D_anniAtSinks") {
            D_anniAtSinks = rate_value;
        } else if (rate_name == "VD_mutualAnni") {
            VD_mutualAnni = rate_value;
        } else if (rate_name == "Rrot") {
            Rrot = rate_value;
        } else if (rate_name == "RTransRot") {
            RTransRot = rate_value;
        } else if (rate_name == "RTrans") {
            RTrans = rate_value;
        } else if (rate_name == "RnnnTrans") {
            RnnnTrans = rate_value;
        } else if (rate_name == "V_DiffCoeff") {
            V_DiffCoeff = rate_value;
            if(V_DiffCoeff > 1.0) error->all(FLERR, ("bcc/selfdiffusion V_DiffCoeff cannot be > 1.0\n"));
        } else {
            error->all(FLERR, ("Unknown bcc/selfdiffusion rate name: " + rate_name).c_str());
        }
    } 
    else if (strcmp(arg[0], "energy") == 0) {
       if (narg != 3) {
            error->all(FLERR, "Illegal bcc/selfdiffusion rate command: "
                               "Expected 'energy <name> <value>'");
        } 
        std::string energy = arg[1]; // The name of the energy variable (e.g., "V-V")
        double energy_value = std::atof(arg[2]); // Using std::atof as requested

        // Assign the value to the corresponding member variable
        if (energy == "VV") {
            VV = energy_value;
        } else if (energy == "DD") {
            DD = energy_value;
        } else if (energy == "DV") {
            DV = energy_value;
        } else {
            error->all(FLERR, ("Unknown bcc/selfdiffusion energy name: "+std::to_string(energy_value)).c_str());
        }
    }
    else {
        error->all(FLERR, "Illegal bcc/selfdiffusion command: "
                           "Expected 'energy', or 'rate'");
    }
} 


/* ----------------------------------------------------------------------
   set site value ptrs each time iarray/darray are reallocated
------------------------------------------------------------------------- */

void AppBccSelfdiffusion::grow_app()
{
  lattice = iarray[0];  //vac=1, reg=2, dumbbell=3 - 8: i1
}

/* ----------------------------------------------------------------------
   initialize before each run
   check validity of site values
------------------------------------------------------------------------- */

void AppBccSelfdiffusion::init_app()
{
   if (!allocated) allocate_data();
   allocated = 1;

   dimension = domain->dimension;
   dt_sweep = 1.0/maxneigh;

   double PTot = Rrot + RTransRot + RTrans + RnnnTrans;
   P_rot = Rrot/PTot;
   P_nntr = RTransRot/PTot;
   P_nnt = RTrans/PTot;
   P_nnntr = RnnnTrans/PTot;
   P_vdiff = V_DiffCoeff;
}

/* ----------------------------------------------------------------------
   setup before each run
------------------------------------------------------------------------- */

void AppBccSelfdiffusion::setup_app()
{
  for (int i = 0; i < nlocal+nghost; i++) echeck[i] = 0;

  // clear event list

  nevents = 0;
  for (int i = 0; i < nlocal; i++) firstevent[i] = -1;
  for (int i = 0; i < maxevent; i++) events[i].next = i+1;
  freeevent = 0;
}

/* ----------------------------------------------------------------------
   compute energy of site
------------------------------------------------------------------------- */

double AppBccSelfdiffusion::site_energy(int i)
{
  // energy of site = sum of bond weights
  // default values are JDD = 2, JVV = 1, JVD = -1,   


   double energy = 0.0;
   int ip = lattice[i];
   for (int j = 0; j < numneigh[i]; j++){
      int nj = neighbor[i][j];
      int jp = lattice[nj];
      if (ip>2 && jp>2) //if neighboring dumbbells
          energy += DD;
      else if (ip==1 && jp==1) // if neighboring vacancies
          energy += VV;
      else if ((ip>2 && jp==1) || (ip==1 && jp>2)) //if dumbbell and vac
          energy += DV;
      }
   return 0.5*energy;
}

/* ----------------------------------------------------------------------
   rKMC Method
------------------------------------------------------------------------- */

void AppBccSelfdiffusion::site_event_rejection(int i, RandomPark *random)
{

  // This app assigns spin = 1 for Vac, 2 for Fe, 3 to 8 for dumbbells in
  // 6 <110> orientations with all 8 spins on regular BCC sites.
  // It attempts diffusion of vacancies by exchanging with Fe and dumbbels,
  // and annihilates both vacancy and dumbbell when they meet with rate of
  // VD_mutualAnni.
  // Dumbbells can also diffusion and change configuration as follows:  
  // Dumbbells can rotate onsite, translate to nn, translate to nn & rotate,
  // or translate to nnn and rotate by 90 degrees.
  // Both dumbbell interstitials and vacancies can be annihilated at sinks
  // at a specified rate.  Note, no mass conservation is enforced, they
  // both simply become regular Fe sites.

  double einitial,edelta;
  int i_old, j_old, i_new, j_new;
  int j, nbor, nnnTR=0;
  double P, P_event;

  if (lattice[i] > 2){

    //annihilation of dumbbells at sinks
    P = random->uniform();
    if (P <= D_anniAtSinks) { 
	lattice[i] = 2;
	naccept++;
	naccept_danni++;
	return;
    }
    
    // Rotate dumbbells to another randomly selected orientation 
    // that is 60 degrees
    P_event = random->uniform();
    if (P <= P_rot) {
	while(!0){
	  i_new = (int) (6*random->uniform() + 3);
          i_old = lattice[i];
	  if (i_new != i_old) {
	   if (i_old == 3){
	     if (i_new != 4) break;
	   } else if (i_old == 4) {
	     if (i_new != 3) break;
	   } else if (i_old == 5) {
	     if (i_new != 6) break;
	   } else if (i_old == 6) {
	     if (i_new != 5) break;
	   } else if (i_old == 7) {
	     if (i_new != 8) break;
	   } else if (i_old == 8) {
	     if (i_new != 7) break;
	     }
           }
	}
	  //DEBUG
          //printf("Onsite rotation, old_spin[%i] = %i, ",i,lattice[i]);
	  lattice[i] = i_new;
          naccept++;
	  naccept_rot++;
          return;
    }

    // else attempt translation or translation + rotation with randomly 
    // selected neighbor
    else if (P_event <= P_rot + P_nntr){
      nbor = (int) (4*random->uniform());
      if (nbor >= 4) nbor = 3;
      i_old = lattice[i];

      if(i_old==3){ // [1-10] can rotate to [01-1]=6 & [10-1]=8
        if(nbor == 0) { j = neighbor[i][2];
        } else if(nbor == 1) { j = neighbor[i][3];
        } else if(nbor == 2) { j = neighbor[i][4];
        } else if(nbor == 3) { j = neighbor[i][5];
          }
        j_new = 6;
        if (random->uniform() <= 0.5) j_new = 8;
      } else if (i_old==4) {
        if(nbor == 0) { j = neighbor[i][0];
        } else if(nbor == 1) { j = neighbor[i][1];
        } else if(nbor == 2) { j = neighbor[i][6];
        } else if(nbor == 3) { j = neighbor[i][7];
          }
        j_new = 5;
        if (random->uniform() <= 0.5) j_new = 7;
      } else if (i_old==5) {
        if(nbor == 0) { j = neighbor[i][0];
        } else if(nbor == 1) { j = neighbor[i][3];
        } else if(nbor == 2) { j = neighbor[i][4];
        } else if(nbor == 3) { j = neighbor[i][7];
          }
        j_new = 4;
        if (random->uniform() <= 0.5) j_new = 7;
      } else if (i_old==6) {
        if(nbor == 0) { j = neighbor[i][1];
        } else if(nbor == 1) { j = neighbor[i][2];
        } else if(nbor == 2) { j = neighbor[i][5];
        } else if(nbor == 3) { j = neighbor[i][6];
          }
        j_new = 3;
        if (random->uniform() <= 0.5) j_new = 8;
      } else if (i_old==7) {
        if(nbor == 0) { j = neighbor[i][0];
        } else if(nbor == 1) { j = neighbor[i][2];
        } else if(nbor == 2) { j = neighbor[i][5];
        } else if(nbor == 3) { j = neighbor[i][7];
          }
        j_new = 4;
        if (random->uniform() <= 0.5) j_new = 5;
      } else if (i_old==8) {
        if(nbor == 0) { j = neighbor[i][1];
        } else if(nbor == 1) { j = neighbor[i][3];
        } else if(nbor == 2) { j = neighbor[i][4];
        } else if(nbor == 3) { j = neighbor[i][6];
          }
        j_new = 3;
        if (random->uniform() <= 0.5) j_new = 6;
      }
    }
    else if (P_event <= P_rot + P_nntr + P_nnntr ){
      nnnTR = 1;
      nbor = (int) (4*random->uniform());
      if (nbor >= 4) nbor = 3;
      i_old = lattice[i];
      if(lattice[i] > 8 || lattice[j] > 8) printf("entering nnntr loop, lattice[%i] = %i\n", i,lattice[i]);

      // translate to acceptable neighbor site,
      // select correct orientation (90 degree).
      if(i_old==3 || i_old==4) { // orientation of the dumbbell is (1-10) (110)
        if(nbor == 0) { j = neighbor[i][8];
        } else if(nbor == 1) { j = neighbor[i][9];
        } else if(nbor == 2) { j = neighbor[i][12];
        } else if(nbor == 3) { j = neighbor[i][13];
        }
        j_new = 3;
        if (i_old==3) j_new = 4;
      } else if(i_old==5 || i_old==6) { // (011) (01-1)
        if(nbor == 0) { j = neighbor[i][9];
        } else if(nbor == 1) { j = neighbor[i][10];
        } else if(nbor == 2) { j = neighbor[i][11];
        } else if(nbor == 3) { j = neighbor[i][12];
        }
        j_new = 5;
        if (i_old==5) j_new = 6;
      } else if(i_old==7 || i_old==8) { // (101) (10-1)
        if(nbor == 0) { j = neighbor[i][8];
        } else if(nbor == 1) { j = neighbor[i][10];
        } else if(nbor == 2) { j = neighbor[i][11];
        } else if(nbor == 3) { j = neighbor[i][13];
        }
        j_new = 7;
        if (i_old==7) j_new = 8;
      }
      if(lattice[i] > 8 || lattice[j]>8) printf("exiting nnntr loop, lattice[%i] = %i\n", i,lattice[i]);
      //printf("attempting nnntrans+rot, i_old[%i] = %i, neigh = %i, j_old[%i] = %i, i_new = %i, j_new = %i\n", i,i_old,nbor,j,j_old,i_new,j_new);
    }
    else {
      error->all(FLERR,"In rKMC, P_event is out of bounds\n");
    }

      //if neighbor is another dumbbell, return
      if (lattice[j] > 2){
	 return;
      }

      //if neighbor is a vacancy, i&j can become Fe regular sites
      // if not annihilated, return.
      if (lattice[j] == 1){
        P = random->uniform();
	if(P <= VD_mutualAnni) {
           //DEBUG
           //printf("annihilate, old_spin_i[%i] = %i, old_spin_j[%i] = %i, ", i,lattice[i],j,lattice[j]);
           lattice[i] = 2;
	   lattice[j] = 2;
           naccept++;
	   naccept_dvanni++;
	   return;
	}
	return;
      }

      i_old = lattice[i];
      j_old = lattice[j];
      einitial = site_energy(i)+site_energy(j);
      i_new = j_old;

      lattice[i] = i_new;
      lattice[j] = j_new;
      edelta = site_energy(i) + site_energy(j) - einitial;

      if(edelta <= 0.0){
        naccept++;
        if(nnnTR) naccept_nnntr++;
        else naccept_nntr++;
        return;
      }
      else if (temperature > 0.0){ 
        P = random->uniform();
	if(P <= exp(-1*edelta*t_inverse)) {
	   naccept++;
           if(nnnTR) naccept_nnntr++;
           else naccept_nntr++;
	   return;
        }
        else{
	  lattice[i] = i_old;
	  lattice[j] = j_old;
	  return;
        }
      }
    }
  else if (lattice[i] == 1){

    // annihilation of vacancies at sinks
    P = random->uniform();
    if (P <= V_anniAtSinks) { 
	lattice[i] = 2;
	naccept++;
	naccept_vanni++;
	return;
    }

    int nbor = (int) (8*random->uniform());
    if (nbor >= 8) nbor = 7;
    int j = neighbor[i][nbor];
      
    // if another vacancy, return
    if (lattice[i] == lattice[j]) return;

    // if vac and neigh is D, annihilate or return.
    else if (lattice[j] > 2){
       P = random->uniform();
       if(P <= VD_mutualAnni){
           lattice[i] = 2;
           lattice[j] = 2;
           naccept++;
	   naccept_dvanni++;
           return;
       }
       return; 
    }

    if(lattice[j] != 2) printf("Error in lattice loop\n");
    // Vacancy diffusion rate is V_DiffCoeff
    P = random->uniform();
    if (P > V_DiffCoeff)
       return;

    i_old = lattice[i];
    j_old = lattice[j];
    einitial = site_energy(i)+site_energy(j);

    lattice[i] = j_old;
    lattice[j] = i_old;
    edelta = site_energy(i)+site_energy(j) - einitial;

    if(edelta <= 0.0){
	  naccept++;
	  naccept_VFex++;
	  return;
    } 
    else if (temperature > 0.0){ 
          P = random->uniform();
	  if(P <= exp(-1*edelta*t_inverse)) {
	    naccept++;
	    naccept_VFex++;
	    return;
          }
    }
    else{
	  lattice[i] = i_old; 
	  lattice[j] = j_old;
	  return;
    } 
  } 
}

/* ----------------------------------------------------------------------
   KMC method
   compute total propensity of owned site summed over possible events
------------------------------------------------------------------------- */

double AppBccSelfdiffusion::site_propensity(int i)
{
  error->all(FLERR,"kMC has been disabled in this version. Use rkMC\n");
  int j,k, i_old, j_old, eflag;
  double e0,einitial,edelta,probone,proball;

  clear_events(i);

  i_old = lattice[i];
  proball = 0.0;
  probone = 0.0;

  // if i is a dumbbell
  if(lattice[i] > 2) {

  // This more efficient way of annihilating dumbbells does not work. It 
  // overruns the propensity of the site while selecting events.
  // When embedded in the loop over neighbors, it works.
  /*
   *  i_old = lattice[i]; 
   *  //D can be annihilated at a sink or ...
   *  proball += probone = numneigh[i]*D_anniAtSinks; 
   *  add_event(i,-1,probone,ANNIATSINK);
   */

     //... or rotate onsite or ...
     // proball += probone = Rrot; 
     proball += probone = (double) maxneigh*Rrot*(1-D_anniAtSinks); 
     //proball += probone = Rrot*(1-D_anniAtSinks); 
     add_event(i,-1,probone,ONSITEROT);

     for(j = 0; j < numneigh[i]; j++){
           i_old = lattice[i];
	   j_old = lattice[neighbor[i][j]]; 
           proball += probone = D_anniAtSinks; 
           //printf("In add_event, danni = %f, maxneigh = %i, probone = %f, proball = %f\n", D_anniAtSinks, maxneigh, probone, proball);
           add_event(i,-1,D_anniAtSinks,ANNIATSINK);

	// ...or annihilate w/ vacancy or ...
          if(j_old == 1) {
	   proball += probone = VD_mutualAnni; 
	   add_event(i,neighbor[i][j],probone,ANNI);
	   }

	// ... or translate or translate+rotate w/ V or Fe nn or 
        // translate+rot w/nnn or ...
	//  if(lattice[neighbor[i][j]] < 3) { 
        // ****** Text no D and V exchange
	  if(lattice[neighbor[i][j]] == 2) {
           einitial = site_energy(i) + site_energy(j);
           // Since the energy of a dumbbell does not depend on its orientation,
           // edelta can be calculate now.
	   lattice[i] = j_old;
	   lattice[neighbor[i][j]] = i_old;
           edelta = site_energy(i) + site_energy(j) - einitial;

 	   // translate or translate + rotate with nn
	   if(j < 8){
	      int exchange = 1;
	      if(i_old==3){ // orientation of the dumbbell is (1-10)
           	if(j==0 || j==1 || j==6 || j==7){
                   exchange = 0;}}
       	      else if(i_old==4){ // (110)
             	if(j==2 || j==3 || j==4 || j==5){
                   exchange = 0;}}
              else if(i_old==5){ // (011)
           	if(j==1 || j==2 || j==5 || j==6){
                   exchange = 0;}}
              else if(i_old==6){ // 01-1)
           	if(j==0 || j==3 || j==4 || j==7){
                   exchange = 0;}}
              else if(i_old==7){ // (101)
           	if(j==1 || j==3 || j==4 || j==6){
                   exchange = 0;}}
              else if(i_old==8){ // (10-1)
           	if(j==0 || j==2 || j==5 || j==7){
                   exchange = 0;}}
	      if(exchange == 1){
	         if(edelta <= 0.0){
		    if(j_old == 1) proball += probone = (1.0-VD_mutualAnni)*RTrans;
		    else proball += probone = RTrans;
	   	    add_event(i,neighbor[i][j],probone,TRANS);
		    //DEBUG
		    //printf("Added TRANS with lattice[i=%i] = %i, lattice[j=%i]=%i, prob = %f\n", i,lattice[i],neighbor[i][j],lattice[neighbor[i][j]],probone);
		    if(j_old == 1) proball += probone = (1-VD_mutualAnni)*(1.0-RTrans);
		    else proball += probone = (1.0-RTrans);
	   	    add_event(i,neighbor[i][j],probone,NNTRANSROT);
	      	 }
	         else if (temperature > 0.0){
		    if(j_old == 1) proball += probone = (1.0-D_anniAtSinks) * 
				   exp(-1.0*edelta*t_inverse);
		    else proball += probone = RTrans * exp(-1.0*edelta*t_inverse);
	   	    add_event(i,neighbor[i][j],probone,TRANS);

		    if(j_old == 1) proball += probone = (1.0-VD_mutualAnni) *
		                   (1.0-RTrans) * exp(-1.0*edelta*t_inverse);
		    else proball += probone = (1.0-RTrans) * exp(-1.0*edelta*t_inverse);
	   	    add_event(i,neighbor[i][j],probone,NNTRANSROT);
	      	 }
	      }
	   }
	   // translate + rotate 90 degrees with nnn
	   else { 
	      int exchange = 1;
	      if(i_old==3 || i_old==4) { // orientation of the dumbbell is (1-10) (110)
           	if(j==10 || j==11){
              	  exchange = 0;}}
              if(i_old==5 || i_old==6) { // (011) (01-1)
           	if(j==8 || j==13){
              	  exchange = 0;}}
              if(i_old==7 || i_old==8) { // (101) (10-1)
                if(j==9 || j==12){
                  exchange = 0;}}
	      if(exchange == 1){
	         if(edelta <= 0.0){ 
		    if (j_old == 1) proball += probone = 1.0-VD_mutualAnni; 
		    else proball += probone = 1.0; 
	   	    add_event(i,neighbor[i][j],probone,NNNTRANSROT);
		 }
	         else if (temperature > 0.0){
		     if(j_old == 1) proball += probone = (1.0-VD_mutualAnni) *
				    exp(-1.0*edelta*t_inverse);
		     else proball += probone = exp(-1.0*edelta*t_inverse);
	   	     add_event(i,neighbor[i][j],probone,NNNTRANSROT);
		 }
	      }
	   }
	   lattice[i] = i_old;
	   lattice[neighbor[i][j]] = j_old;
	}
	// DEBUG
	// else{
	  // if(lattice[neighbor[i][j]] < 3) 
	     // printf("Error, D skipped anni and trans/transrot incorrectly\n");
        //}
     } 
  }
  // If vacancy, then annihilation at sink and exchange with neighboring
  // Fe site are the possible events.
  else if(lattice[i] == 1) {
     proball += probone = maxneigh*V_anniAtSinks;
     add_event(i,-1,probone,ANNIATSINK);

     for(j = 0; j < numneigh[i]; j++){
	i_old = lattice[i];
	j_old = lattice[neighbor[i][j]];

        // if vac and dumbbell, annihilate both at rate=VD_mutualAnni
	if(j_old > 2){
	   proball += probone = VD_mutualAnni; 
	   add_event(i,neighbor[i][j],probone,ANNI);
	}
    
        // if vac and Fe or D, calculate probability of exchange
	// if(lattice[neighbor[i][j]] > 1) {
        // ****** Test no V and D exchange
	if(lattice[neighbor[i][j]] == 2) {
           einitial = site_energy(i) + site_energy(j);
	   lattice[i] = j_old;
	   lattice[neighbor[i][j]] = i_old;
           edelta = site_energy(i) + site_energy(j) - einitial;
	   probone = 0.0;
	   if(edelta <= 0.0){ 
	      if (j_old > 2) proball += probone = 1.0*(1.0-VD_mutualAnni);
	      else proball += probone = 1.0;
	   }
	   else if (temperature > 0.0) {
	      if(j_old > 1) proball += probone = (1.0-VD_mutualAnni)*exp(-1.0*edelta*t_inverse);
	      else proball += probone = exp(-1.0*edelta*t_inverse);
	   }
	   if(probone > 0.0) {
		add_event(i,neighbor[i][j],probone,EXCHANGE);
	   }
	}
	lattice[i] = i_old;
	lattice[neighbor[i][j]] = j_old;
     }
  }
  return proball;
}

/* ----------------------------------------------------------------------
   KMC method
   choose and perform an event for site
------------------------------------------------------------------------- */

void AppBccSelfdiffusion::site_event(int i, class RandomPark *random)
{
  return site_event_linear(i,random);
}

/* ---------------------------------------------------------------------- */

void AppBccSelfdiffusion::site_event_linear(int i, class RandomPark *random)
{
  int j,k,m,isite,i_old,j_old,i_new,j_new;

  // pick one event from total propensity by accumulating its probability
  // compare prob to threshhold, break when reach it to select event
  // perform event

  double threshhold = random->uniform() * propensity[i2site[i]];
  double proball = 0.0;
  int updatejnbors = 0;

  int ievent = firstevent[i];
  while (1) {
    proball += events[ievent].propensity;
    if (proball >= threshhold) break;
    ievent = events[ievent].next;
    //printf("i = %i, propensity = %f, threshhold = %f, proball =%f\n", i, propensity[i2site[i]],threshhold, proball);
    if (ievent < 0) {
         printf("i = %i, propensity = %f, threshhold = %f, proball =%f\n", i, propensity[i2site[i]],threshhold, proball);
         error->one(FLERR,"Did not reach event propensity threshhold");
    }
  }

  if (events[ievent].style == ANNIATSINK){
     j = events[ievent].destination;
     //DEBUG
     // if(j != -1 || lattice[i] == 2) 
	// printf("Error, Annihilate at sink.\n");
     if(lattice[i] > 2) {
	naccept_danni++;
     }	
     else { 
	naccept_vanni++;
     }
     lattice[i] = 2;
  }

  else if (events[ievent].style == ANNI){
     j = events[ievent].destination;
     // DEBUG
     // if(lattice[i] == 2 || lattice[j] == 2){
        // printf("Error, trying to annihilate incorrectly.");
        // printf(" lattice[%i] = %i, lattice[%i] = %i\n", i,lattice[i], j,lattice[j]);}
     lattice[i] = 2;
     lattice[j] = 2;
     updatejnbors = 1;
     naccept_dvanni++;
  }

  else if (events[ievent].style == ONSITEROT) {
     j = events[ievent].destination;
     // DEBUG
     // if(j != -1 || lattice[i] < 3) {
	// printf("Error, trying to rotate on site incorrectly.\n");}
     while(!0){
	i_new = (int) (6*random->uniform() + 3);
	if(i_new > 8 || i_new < 3){ 
	   printf("Error, i_new for onsite rotation is out of bounds\n");}
        i_old = lattice[i];
	if (i_new != i_old) {
	   if (i_old == 3){
	     if (i_new != 4) break;
	   } else if (i_old == 4) {
	     if (i_new != 3) break;
	   } else if (i_old == 5) {
	     if (i_new != 6) break;
	   } else if (i_old == 6) {
	     if (i_new != 5) break;
	   } else if (i_old == 7) {
	     if (i_new != 8) break;
	   } else if (i_old == 8) {
	     if (i_new != 7) break;
	   }
	}
     }
     lattice[i] = i_new;
     naccept_rot++;
  }
  else if (events[ievent].style == TRANS) {
     j = events[ievent].destination;
     // DEBUG, assumes i is a dumbbell and j is M or V
     // if (lattice[i] < 3 || lattice[j] > 2) printf("Error, incorrect TRANS.\n");
     j_old = lattice[j];
     lattice[j] = lattice[i];
     lattice[i] = j_old;
     updatejnbors = 1;
     naccept_nnt++;
  }
  else if (events[ievent].style == NNTRANSROT) {
     j = events[ievent].destination;
     // DEBUG
      if (lattice[i] < 3 || lattice[j] > 2){ 
	 printf("Error, incorrect NNTRANSROT.\n");}
     while(!0){
	j_new = (int) (6*random->uniform() + 3);
	if(j_new > 8 || j_new < 3) printf("Error, j_new for trans+rotation is out of bounds\n");
	if (j_new != lattice[i]) break;
     }
     j_old = lattice[j];
     lattice[j] = j_new;
     lattice[i] = j_old;
     updatejnbors = 1;
     naccept_nntr++;
  }
  else if (events[ievent].style == NNNTRANSROT) {
     j = events[ievent].destination;
      //DEBUG
      if (lattice[i] < 3 || lattice[j] > 2) {
	 printf("Error, incorrect NNNTRANSROT. i = %i, j = %i\n", lattice[i], lattice[j]);}
     j_old = lattice[j];
     i_old = lattice[i];
     if (i_old == 3) j_new = 4; // (1-10)
     else if (i_old == 4) j_new = 3;
     else if (i_old == 5) j_new = 6;
     else if (i_old == 6)j_new = 5;
     else if (i_old==7) j_new = 8;
     else j_new = 7;
     lattice[j] = j_new;
     lattice[i] = j_old;
     updatejnbors = 1;
     naccept_nnntr++;
  }
  else if (events[ievent].style == EXCHANGE) {
     j = events[ievent].destination;
     i_old = lattice[i];
     if((lattice[i] == 1 && lattice[j] > 2) || (lattice[i] > 2 && lattice[j] == 1)){
	//naccept_VDex++;
	printf("Error, should not be in this loop, spin[%i]=%i & spin[%i]=%i\n", i, i_old,j, lattice[j]);
     }
     else if((lattice[i] == 1 && lattice[j] == 2) || (lattice[i] == 2 && lattice[j] == 1))
	naccept_VFex++;
     lattice[i] = lattice[j];
     lattice[j] = i_old;
     updatejnbors = 1;
  }
  // compute propensity changes for self and swap site and their neighs
  // ignore update of sites with isite < 0
  // use echeck[] to avoid resetting propensity of same site

  int nsites = 0;

  isite = i2site[i];
  propensity[isite] = site_propensity(i);
  esites[nsites++] = isite;
  echeck[isite] = 1;

  // update site i's neighbors, this will include the exchanged site

  for (k = 0; k < numneigh[i]; k++) {
    m = neighbor[i][k];
    isite = i2site[m];
    // not quite sure what this does
    if (isite < 0) continue;
    // add to update list
    esites[nsites++] = isite;
    propensity[isite] = site_propensity(m);
    echeck[isite] = 1;
  }

  // update exchanged site's neighbors
  // avoid any that have already been found

  if (updatejnbors == 1){
     for (k = 0; k < numneigh[j]; k++) {
       m = neighbor[j][k];
       isite = i2site[m];
       // not quite sure what this does
       if (isite < 0) continue;
       // make sure site is not already updated
       if (echeck[isite] == 1) continue;
       // add to update list
       esites[nsites++] = isite;
       propensity[isite] = site_propensity(m);
       echeck[isite] = 1;
     }
  }

  solve->update(nsites,esites,propensity);

  // clear echeck array

  for (k = 0; k < nsites; k++) echeck[esites[k]] = 0;
}

/* ----------------------------------------------------------------------
   clear all events out of list for site I
   add cleared events to free list
------------------------------------------------------------------------- */

void AppBccSelfdiffusion::clear_events(int i)
{
  int next;
  int index = firstevent[i];
  while (index >= 0) {
    next = events[index].next;
    events[index].next = freeevent;
    freeevent = index;
    nevents--;
    index = next;
  }
  firstevent[i] = -1;
}

/* ----------------------------------------------------------------------
   add an event to list for site I
   event = exchange with site J with probability = propensity
------------------------------------------------------------------------- */

void AppBccSelfdiffusion::add_event(int i, int destination,
			      double propensity, int eventflag)
{
  // grow event list and setup free list

  if (nevents == maxevent) {
    maxevent += DELTAEVENT;
    events =
      (Event *) memory->srealloc(events,maxevent*sizeof(Event),"app:events");
    for (int m = nevents; m < maxevent; m++) events[m].next = m+1;
    freeevent = nevents;
  }

  int next = events[freeevent].next;
  events[freeevent].propensity = propensity;
  events[freeevent].destination = destination;
  events[freeevent].style = eventflag;
  events[freeevent].next = firstevent[i];
  firstevent[i] = freeevent;
  freeevent = next;
  nevents++;
}

/* ----------------------------------------------------------------------
   allocate data structs that have to wait until sites exist
   so that nlocal,nghost,maxneigh are set
------------------------------------------------------------------------- */

void AppBccSelfdiffusion::allocate_data()
{
  // for linear:
  //   make esites large enough for 1 sites and their 1,2 neighbors

  if (engstyle == LINEAR) {
    int emax = 1 + maxneigh*2;
    esites = new int[2*emax];
  }

  echeck = new int[nlocal+nghost];

  memory->create(firstevent,nlocal,"app:firstevent");
}
